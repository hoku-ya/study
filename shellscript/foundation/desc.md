# Udemy Linux動画 (セクション16~40:シェルスクリプト)
動画URL↴\
https://www.udemy.com/course/linuxlpic/learn/lecture/20222574#overview


current directory↴\
/mnt/c/Users/HOKUTO/OneDrive - maebashi-it.ac.jp/プログラミング/study/study_programing/shell_script

## shell scriptとは？

Linux OSを操作するための簡易なプログラミング言語  
shell scriptの中でも、bash,sh,csh,zshがあり若干書き方が異なる

この講座ではbashを扱う

<br>

# 16.スクリプトの作成、基本的な内容

[サポートしているシェルを一覧表示]
- cat /etc/shells

[ファイル作成(viコマンドでファイル名の末尾に.shを付ける)]
```sh
#!/bin/bash # 1行目でシェルの場所を指定する

echo 'Hello World' # Hello World表示
# コメント文は#を文頭に記載
exit 0 # 処理終了(0が正常終了、それ以外は異常終了)
```

[実行]
- chmod 755 ファイル名 # パーミッション変更
- ./test.sh # シェルスクリプトの実行

## 1.ファイルbase1.shを作成

```sh base1.sh
#!/bin/bash

echo 'Hello World'
exit 0
```

## 2.実行ファイルの権限を変更

ターミナルで実行
```
chmod 755 base1.sh
```

## 3.ファイルの実行

ターミナルで実行
```
./base1.sh
```
↓↓↓↓↓↓↓\
"Hello World"が表示されたら成功！

## 4.サポートしているシェルの表示
```
$ cat /etc/shells

# /etc/shells: valid login shells
/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/bin/dash
/usr/bin/dash
/usr/bin/tmux
/usr/bin/screen
/bin/zsh
/usr/bin/zsh
```

## 5.コメント

コメントの表示は"#"を先頭につける

```sh base1.sh
#!/bin/bash

# "Hello World"と出力
echo 'Hello World'
exit 0
```

終わり

# 17.変数の使い方

current directory↴\
/mnt/c/Users/HOKUTO/OneDrive - maebashi-it.ac.jp/プログラミング/study/study_programing/shell_script/17

[スクリプト内での変数の定義]
- `var1='変数1’`　#変数の宣言(var1という名前の変数に文字列’変数1’が格納される)
- `` var2=`command` `` #コマンドの実行結果を変数に格納
- `var3=$(command)` #コマンドの実行結果を変数に格納    
<br>
- `echo $var1`　 #変数の中身を取り出す場合には、`$`を付ける

[システム変数の表示]
初めから定義されている変数\
`$BASH, $BASH_VERSION, $HOME, $PWD` #システム変数
- $BASH 現在使っているデフォルトのシェルのパス
- $BASH_VERSION BASHのバージョン
- $HOME ホームディレクトリの位置が表示される
- $PWD カレントディレクトリの位置が表示される

# 18.配列の作成

[配列の作成]\
- `fruits=('banana' 'apple' 'grape')

[配列の表示方法]
- `echo "${fruits[@]}"` #配列の中の値をすべて表示(banana apple grape)
- `echo "${fruits[0]}"` #インデックス0の要素を表示(1番目の要素(banana))
- `echo "${!fruits[@]}"` #インデックスを表示(0 1 2)
- `echo "${#fruits[@]}"` #配列の要素の数を表示(3)
<br>
<br>
- `fruits[3]='lemon'` #配列のインデックス3(4番目)にlemonを追加\
- `unset fruits[2]` #配列のインデックス2(3番目)を削除

# 19.引数、返り値の使い方
[引数とは]\
実行する際に、シェルに渡す値  
`./○○.sh a b` # a:第一引数 b:第二引数

<br>

- `echo $1 $2 $3` # 第1引数、第2引数、第3引数を表示

<br>

- `echo $0` # シェルスクリプトのファイル名

<br>


- `echo $@` # 全引数を表示
- `echo $#` # 引数の数を表示
- `$?` # 直前に実行したコマンドの戻り値(成功の場合0)

<br>

シェルスクリプトから別のシェルスクリプトを呼び出すことも可能

# 20.ファイル出力、標準入力
[標準入出力]\
標準入力:ターミナルからの値の読み取り。\
標準出力:ターミナルでの値の表示。
- `read var` # 標準入力
- `echo var1 = $var` # 入力結果表示

<br>

- `read var1 var2 var3` # 入力結果から3個変数を設定→入力はスペースで区切る
- `echo var1 = $var1, var2 = $var2, var3 = $var3`

<br>

- `read -p 'var1: 'var1` # 文字付きの標準入力
- `read -sp 'password:' password` # シークレットモードでの標準入力
- `read -a names` # 配列(Array)入力→入力はスペースで区切る

<br>

[ファイル出力]
- `>:上書き`
- `echo 'hello' > hello.txt` # 現在いるディレクトリのhello.txtファイルを作成(上書き)してhelloを書き込む。
- `>>:追記` # 現在いるディレクトリのhello.txtファイルを作成（追記）してhelloを書き込む


# 21.制御(if文)

**if文の書き方(3通り)**
1. `if test 条件文;`
2. `if [条件文];`
3. `if[[条件文]];`

<br>

```sh
if test 条件文; or [条件文]; or [[条件文]];
then
  プログラム # ifの条件を満たすときに実行される
elif test 条件文; or [条件文]; or [[条件文]]; # ifの条件文を満たしていない場合に実行される
then
  プログラム # elifの条件文を満たす場合に処理が実行される
else
  プログラム # ifもelifも満たさない場合に実行される
fi
```

<br>

- `=, !=` # 文字列で等しいか等しくないか
- `-eq(=), -ne(!=), -lt(<), -gt(>), -ge(≧)` # 数値比較


# 22.制御(if文(and, or))
**条件文1 and 条件文2の場合、条件文1,条件文2を両方満たす場合に実行**<br>
書き方は以下の4通り

- `if [条件文1] && [条件文2];`
- `if [条件文1 -a 条件文2];`
- `if [[条件文1 && 条件文2]];`
- `if test 条件文1 && test 条件文2;`

<br>

**条件文1　or 条件文2の場合、条件文1 or 条件文2のどちらかを満たす場合に実行**

- `if [条件文1] || [条件文2];`
- `if [条件文1 -o 条件文2];`
- `if [条件文1 || 条件文2];`
- `if test 条件文1 || test 条件文2;`

<br>

**否定を表す条件文(3つ)**

- `if ! test 条件文`
- `if [! 条件文]`
- `if [[! 条件文]]`

<br>

- `cmd1 && cmd2` # cmd1が正しく実行されたらcmd2を実行
- `cmd1 || cmd2` # cmd1がエラーならcmd2を実行
- `cmd1 && cmd2 || cmd3` # cmd1が正しく実行されたらcmdが実行されて、cmd1がエラーならmcd3を実行

# 23.制御(if文(ファイル存在チェック))
```sh
if [-e ファイル名]; # ファイルもしくはディレクトリの存在確認
then
else
fi
```

- `if [ -f ファイル名 ]` # ファイルが存在しディレクトリでなくファイル
- `if [ -d ファイル名 ]` # ディレクトリが存在するか
- `if [ -s ファイル名 ]` # ディレクトリ or 中身のあるファイルか
- `if [ -w ファイル名 ]` # 書き込み権限あるか
- `if [ -x ファイル名 ]` # 実行権限あるか
- `if [ fileA -nt fileB ]` # fileAがfileBより新しいか
- `if [ fileA -ot fileB ]` # fileAがfileBより古いか

# 24.25．なし

# 26.数値計算1(四則演算)
[シェルスクリプトでの四則演算]\
シェルスクリプトでは、シンプルに1＋1と書いても、計算をしてくれない。
四則演算をするには、少し特殊な書き方が必要。

- `echo 1+1` # 1+1と表示されて、計算結果(2)が表示されない
- `echo $((1+1))` # 2と表示される。 +(和),-(差),*(積),/(商),%(剰余)
- `echo $(expr 1+1)` # 2と表示される。 +(和),-(差),`\`*(積),/(商),%(剰余)

[変数を使った四則演算]
- `num1=1`
- `num2=2`
- `echo $(num1 + num2)` +(和),-(差),*(積),/(商),%(剰余)

<br>

- `echo $(expr $num1 + $num2)` +(和),-(差),`\`*(積),/(商),%(剰余)
- `echo $(expr $num1 \*  $num2)`

# 27.数値計算2(複雑な計算)
[複雑な数値計算]\
ここでは、単純な四則演算でなくより複雑な数値計算(浮動小数点演算など)を実行してみます。

<br>

bcコマンドのインストール(yum install bc)\
**bcコマンドは、任意の制度（小数点以下の桁数を指定）の数値を扱い、四則演算・平方根・三角関数など様々な数学関数を計算できるコマンドです。**\
**計算内容を文字列として|を使って、bcコマンドに渡すと計算されます。**

<br>

- `echo "20.5+5" | bc` # bcコマンドで文字列20.5＋5を計算する（25.5）
- `echo "20.5*5" | bc` # bcコマンドで文字列20.5*5を計算する（102.5）

<br>

- `echo "scale=20;sqrt(20.5/5)" | bc -l`   # -lを利用すると標準ライブラリを読み込んでより複雑な数学関数を実行します。

<br>

- `echo "$num1+&num2" | bc` # 変数を使用してもbcコマンドを利用できます 

# 28.Case文
**ある変数を評価して、値に応じて処理を変える**

```sh
case $var in # varはチェックする変数
  パターン1) # $varがパターン1に該当する場合に実行される
    プログラム1;;
  パターン2) # $varがパターン2に該当する場合に実行される
    プログラム2;;
  *) # $varがパターン1にもパターン2にも該当しない場合に実行される
    プログラム3;;
esac
```

**パターンの記載方法**
- `[a-z]`:a-zまでの場合
- `[A-Z]`:A-Zまでの場合
- `[0-9]`:0-9までの場合


# 29.ループ1(while, until, for, break, continue)
**while文はループ文の一種でwhileの条件を満たしている限り中の処理を実行し続けます**
<br>

```sh
while [文字列の比較] ((数値の比較)) # nが10以下の場合にwhileの中の処理を実行
do
  プログラム
  sleep 1 # 1秒処理が止まる
done
```

<br>

**ファイルの読み込み（変数pの中にファイルの中身が1行ずつ読み込まれます）**
```sh
while read p
do
  プログラム
done < aa.txt
cat aa.txt | while read p
do
  statement
done
```

<br>

**until文はループ文の一種でuntilの条件を満たすまで中の処理を実行し続ける**

```sh
until [文字列の比較]((数値の比較))
do
  statement
done
```
<br>

- break: while文、until文の中にbreakを入れるとそれが実行された時点でループの外に出る
- continue: while文、until文の中にcontinueを入れるとそこでループの以降の処理が実行されず、次のループに移る

# 30.ループ2(for文)
**for文はループ文の一種で条件にある値を変数格納してループ内の処理を実行し続けます**
```sh
# 変数varに1,2,3,4,5を代入していきます
for var in 1 2 3 4 5 

# seq 1 10:1~10までの整数 
# seq 1 2 10:1~10まで+2ずつ 1 3 5 7 9
for i in `seq 1 10`, for i in `seq 1 2 10`

# 変数commandにls pwd dateを代入していきます
for command in ls pwd date; 
do
  echo $command
  $command
done
```

# 31.



# 32.



# 33.応用1(select文)
**selectを利用すると複数の文字の中から、どれを選ぶのか数値で選択することができる。ユーザに数値を選択させて、それに応じて処理をさせたい場合に用いる。**

```sh
#ユーザが入力して、1) apple 2) banana 3) lemonの中から選択する(変数varに1の場合はapple、2の場合はbanana、3の場合はlemon、1,2,3以外の入力の場合空白が入る)
select var in apple banana lemon 
do
  echo $var
  break # breakでselectの外に出る
done
```

# 34.応用1(関数, local変数)
**関数を定義(function 関数名())**  
関数の中から引数を利用する場合には`$1`を用いる

```sh
function hello(){
  プログラム
  echo $1 # 第一引数
}

hello # 関数の呼び出し（引数なし）
hello 'hello' # 第一引数を'hello'で関数helloの呼び出し
```
<br>

関数の中で同名の変数を変更すると関数の外でも変更されてしまう

```sh
function hello(){
  name=$1
  echo $name
}

name=Tom
echo $name
hello Miki
echo $name # nameの値がhello関数の中で変更される(Mikiになる)

function hello(){
  local name=$1 # 変数宣言の前にlocalを付けると変数を関数の中だけ専用利用できる
}


```


# 35.応用2(read only, PIDの利用, trapの利用)
**値を変更できないようにするには、readonlyを用いる**
```sh
var=31
readonly var # readonlyを設定
var=41 # 値を変更するとエラーになる

function hello(){
  echo "hello world"
}
readonly -f hello #関数をreadonlyに設定
# 同じ関数を後で設定することができなくなる
```

<br>

**例えば、以下の場合にシェルスクリプト内でプロセスIDを用いることがある**
- 特定のプロセスを落とす
- プロセスIDをファイルに記憶する

```sh
pid is $$ # 自分のプロセスID
```

<br>

**trapコマンドでプログラム終了時の挙動を設定する**\

```sh
# プログラム終了時に実行されるコマンド
# 終了時に0なら""内の命令を実行する
trap "echo exit command is detected" 0

# kill -15swのプロセス終了時に実行されるコマンド
# 終了時に15なら""内の命令を実行する
trap "echo Exit" 15 

# 終了時、割り込み時に実行される
# 終了時に0もしくは2なら""内の命令を実行する
trap "rm -f $file && echo file deleted" 0 2
```

- 0:正常終了
- 1:再起動
- 2:割り込み(ctrl+c)
- 9:強制終了(trapでは設定できない)
- 15:プロセスの終了





# 36.



# 37.



# 38.



# 39.シェルスクリプトのデバッグ
**デバッグモードで実行する方法**\
2通りある
- `bash -x ./hello.sh`

- プログラムの文頭に以下を記載
  ```sh
  #!/bin/bash -x
  ```

→全体的にデバッグする方法
<br>

**プログラム内で動的にデバッグにするか変更する方法**\
プログラム中に記入

```sh
set -x #デバッグモード
  プログラムのデバッグを行いたい部分
set -x #元に戻す
```
→部分的に（動的に）デバッグする方法

# 40.


# 61.ストリーム・パイプ・リダイレクト

- ストリーム：キーボードやファイルからプログラムへのデータの入力、プログラムからディスプレイやファイルへのデータの出力などのデータの流れのこと

- 標準入力：プログラムへの入力ストリーム
- 標準出力：プログラムからの出力ストリーム
- 標準エラー出力：プログラムからのエラーメッセージの出力

- パイプ：１つ目のコマンドの標準出力を２つ目のコマンドに渡す(コマンド１|コマンド２)
- `/dev/null`：スペシャルファイルの一つで、そこに書き込まれたデータをすべて捨て(writeシステムコールは成功する)、読みだしてもどんなプロセスに対してもデータを返さない。いらないデータを入れたい場合に使う
- `tee`：標準を画面表示とファイルへの書き込み両方行う。`-a`で追記
- コマンド>ファイル名：標準出力をファイルに上書きして書き込み（リダイレクト）
- コマンド>>ファイル名：標準出力をファイルに追記（リダイレクト）
- コマンド<ファイル名：ファイルを入力としてコマンドに渡す
- コマンド<<文字列：指定した文字列が入力されるまで、標準入力を行う
- コマンド2>ファイル名：標準エラー出力をファイルに書き込む
- コマンド2>>ファイル名：標準エラー出力をファイルに追記

- 2>&1：標準エラー出力を標準入力に渡す。
- 1>&2：標準出力を標準エラー出力に渡す。
- コマンド>ファイル2>&1：標準出力と標準エラー出力をファイルに書き込む→ふつうはエラーがファイルに書き込まれないため。
- コマンド>>ファイル2>&1：標準出力と標準エラー出力をファイルに追記
- コマンド１|コマンド２：コマンド１の標準出力をコマンド２の入力にする
- コマンド１|teeファイル名|コマンド２：コマンド１の標準出力をコマンド２の標準入力にするとともにファイルに書き込む

- xargs：標準入力から読み込んだ内容をコマンドの引数に変換して渡す

